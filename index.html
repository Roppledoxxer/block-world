<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Babylon Greedy Block World</title>
<style>
html, body {
    width: 100%;
    height: 100%;
    margin: 0;
    overflow: hidden;
    background: #000;
}
#renderCanvas {
    width: 100%;
    height: 100%;
    touch-action: none;
}
#hotbar {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 10px;
}
.slot {
    width: 50px;
    height: 50px;
    border: 2px solid #999;
    background: #222;
}
.slot.active {
    border-color: white;
}
</style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<div id="hotbar">
    <div class="slot active"></div>
    <div class="slot"></div>
    <div class="slot"></div>
    <div class="slot"></div>
</div>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);
scene.collisionsEnabled = true;

/* CAMERA */
const camera = new BABYLON.UniversalCamera("cam",
    new BABYLON.Vector3(8, 5, 8), scene);
camera.attachControl(canvas, true);
camera.speed = 0.4;
camera.angularSensibility = 3000;
camera.keysUp.push(87);
camera.keysDown.push(83);
camera.keysLeft.push(65);
camera.keysRight.push(68);
camera.applyGravity = true;
camera.ellipsoid = new BABYLON.Vector3(0.4, 0.9, 0.4);
scene.gravity = new BABYLON.Vector3(0, -0.3, 0);

/* LIGHT */
new BABYLON.HemisphericLight("light",
    new BABYLON.Vector3(0, 1, 0), scene);

/* BLOCK TYPES */
const BLOCKS = {
    AIR: 0,
    GRASS: 1,
    WOOD: 2,
    LEAVES: 3,
    PLANKS: 4
};

const COLORS = {
    1: new BABYLON.Color3(0.2, 0.7, 0.2),
    2: new BABYLON.Color3(0.55, 0.27, 0.07),
    3: new BABYLON.Color3(0.0, 0.4, 0.0),
    4: new BABYLON.Color3(0.85, 0.75, 0.55)
};

/* WORLD DATA */
const SIZE = 16;
const world = [];

for (let x = 0; x < SIZE; x++) {
    world[x] = [];
    for (let y = 0; y < SIZE; y++) {
        world[x][y] = [];
        for (let z = 0; z < SIZE; z++) {
            world[x][y][z] = (y === 0) ? BLOCKS.GRASS : BLOCKS.AIR;
        }
    }
}

/* TREES */
function plantTree(x, z) {
    for (let y = 1; y <= 3; y++) world[x][y][z] = BLOCKS.WOOD;
    for (let dx = -1; dx <= 1; dx++)
    for (let dz = -1; dz <= 1; dz++)
        world[x+dx]?.[4]?.[z+dz] = BLOCKS.LEAVES;
}
plantTree(5,5);
plantTree(10,9);

/* GREEDY MESH */
function buildChunk() {
    if (scene.getMeshByName("chunk"))
        scene.getMeshByName("chunk").dispose();

    const positions = [];
    const indices = [];
    const colors = [];
    let idx = 0;

    function addFace(x,y,z, nx,ny,nz, color) {
        const p = [
            [x,y,z], [x+1,y,z], [x+1,y+1,z], [x,y+1,z],
            [x,y,z+1], [x+1,y,z+1], [x+1,y+1,z+1], [x,y+1,z+1]
        ];
        const faces = {
            "0,0,-1":[0,1,2,3],
            "0,0,1":[5,4,7,6],
            "-1,0,0":[4,0,3,7],
            "1,0,0":[1,5,6,2],
            "0,1,0":[3,2,6,7],
            "0,-1,0":[4,5,1,0]
        }[`${nx},${ny},${nz}`];

        faces.forEach(i=>{
            positions.push(...p[i]);
            colors.push(color.r,color.g,color.b,1);
        });

        indices.push(idx,idx+1,idx+2, idx,idx+2,idx+3);
        idx += 4;
    }

    for (let x=0;x<SIZE;x++)
    for (let y=0;y<SIZE;y++)
    for (let z=0;z<SIZE;z++) {
        const b = world[x][y][z];
        if (!b) continue;
        const c = COLORS[b];

        const dirs = [
            [1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]
        ];
        dirs.forEach(d=>{
            const nx=x+d[0], ny=y+d[1], nz=z+d[2];
            if (!world[nx]?.[ny]?.[nz])
                addFace(x,y,z, d[0],d[1],d[2], c);
        });
    }

    const mesh = new BABYLON.Mesh("chunk", scene);
    const vd = new BABYLON.VertexData();
    vd.positions = positions;
    vd.indices = indices;
    vd.colors = colors;
    vd.applyToMesh(mesh);
    mesh.checkCollisions = true;
}

buildChunk();

/* INVENTORY */
let selected = BLOCKS.PLANKS;
document.addEventListener("keydown", e=>{
    if (e.key >= "1" && e.key <= "4") {
        document.querySelectorAll(".slot")
            .forEach(s=>s.classList.remove("active"));
        document.querySelectorAll(".slot")[e.key-1]
            .classList.add("active");
        selected = [BLOCKS.GRASS,BLOCKS.WOOD,BLOCKS.LEAVES,BLOCKS.PLANKS][e.key-1];
    }
});

/* MINE / PLACE */
scene.onPointerObservable.add(ev=>{
    if (ev.type !== BABYLON.PointerEventTypes.POINTERDOWN) return;
    const ray = scene.createPickingRay(
        scene.pointerX, scene.pointerY,
        BABYLON.Matrix.Identity(), camera);
    const hit = scene.pickWithRay(ray);

    if (!hit.pickedPoint) return;
    const p = hit.pickedPoint;

    const x = Math.floor(p.x);
    const y = Math.floor(p.y);
    const z = Math.floor(p.z);

    if (ev.event.button === 0) {
        world[x]?.[y]?.[z] = BLOCKS.AIR;
    } else {
        world[x]?.[y+1]?.[z] = selected;
    }
    buildChunk();
});

/* RENDER */
engine.runRenderLoop(()=>scene.render());
window.addEventListener("resize", ()=>engine.resize());
</script>
</body>
</html>
